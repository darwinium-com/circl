// Package secretsharing provides methods to split secrets into shares.
//
// Let n be the number of parties, and t the number of corrupted parties such
// that 0 <= t < n. A (t,n) secret sharing allows to split a secret into n
// shares, such that the secret can be recovered from any subset of t+1 shares.
//
// The NewShamirSecretSharing function creates a Shamir secret sharing [1],
// which relies on Lagrange polynomial interpolation.
//
// The NewFeldmanSecretSharing function creates a Feldman secret sharing [2],
// which extends Shamir's by allowing to verify that a share is part of a
// committed secret.
//
// In this implementation, secret sharing is defined over the scalar field of
// a prime order group.
//
// References
//
//	[1] https://dl.acm.org/doi/10.1145/359168.359176
//	[2] https://ieeexplore.ieee.org/document/4568297
package secretsharing

import (
	"fmt"
	"io"

	"github.com/cloudflare/circl/group"
	"github.com/cloudflare/circl/math/polynomial"
)

// Share represents a share of a secret.
type Share struct {
	// ID uniquely identifies a share in a secret sharing instance.
	ID group.Scalar
	// Value stores the share generated by a secret sharing instance.
	Value group.Scalar
}

// SecretSharing provides a (t,n) Shamir's secret sharing. It allows splitting
// a secret into n shares, such that the secret can be only recovered from
// any subset of t+1 shares.
type SecretSharing struct {
	t uint // t is the threshold.
}

// NewShamirSecretSharing implements a (t,n) Shamir's secret sharing with
// threshold t.
func NewShamirSecretSharing(t uint) SecretSharing { return SecretSharing{t} }

// Shard splits a secret into n shares.
func (s SecretSharing) Shard(rnd io.Reader, secret group.Scalar, n uint) ([]Share, error) {
	return NewSplitter(rnd, s.t, secret).multipleShard(n)
}

// Recover returns the secret provided more than t shares are given. Returns an
// error if the number of shares is not above the threshold t.
func (s SecretSharing) Recover(shares []Share) (group.Scalar, error) {
	if l := len(shares); l <= int(s.t) {
		return nil, errThreshold(s.t, uint(l))
	}

	x := make([]group.Scalar, s.t+1)
	px := make([]group.Scalar, s.t+1)
	for i := range shares[:s.t+1] {
		x[i] = shares[i].ID
		px[i] = shares[i].Value
	}

	l := polynomial.NewLagrangePolynomial(x, px)
	zero := shares[0].ID.Group().NewScalar()

	return l.Evaluate(zero), nil
}

type SharesCommitment = []group.Element

// VerifiableSecretSharing provides a (t,n) Feldman's verifiable secret sharing.
// It allows splitting a secret into n shares, such that the secret can be only
// recovered from any subset of t+1 shares.
// It's verifiable as it allows checking whether a share is part of a secret
// committed during sharding.
type VerifiableSecretSharing struct{ s SecretSharing }

// NewFeldmanSecretSharing implements a (t,n) Feldman's verifiable secret
// sharing with threshold t.
func NewFeldmanSecretSharing(t uint) (v VerifiableSecretSharing) { v.s.t = t; return }

// Shard splits the secret into n shares, and also returns a commitment to both
// the secret and the shares. The ShareCommitment must be sent to each party
// so each party can verify its share is correct. Sharding a secret more
// than once produces ShareCommitments with the same first entry.
func (v VerifiableSecretSharing) Shard(rnd io.Reader, secret group.Scalar, n uint) ([]Share, SharesCommitment, error) {
	splitter := NewSplitter(rnd, v.s.t, secret)
	shares, err := splitter.multipleShard(n)
	if err != nil {
		return nil, nil, err
	}

	g := secret.Group()
	shareComs := make(SharesCommitment, splitter.poly.Degree()+1)
	for i := range shareComs {
		shareComs[i] = g.NewElement().MulGen(splitter.poly.Coefficient(uint(i)))
	}

	return shares, shareComs, nil
}

// Verify returns true if a share was produced by sharding a secret. It uses the
// share commitments generated by the Shard function.
func (v VerifiableSecretSharing) Verify(s Share, c SharesCommitment) bool {
	if len(c) != int(v.s.t+1) {
		return false
	}

	g := s.ID.Group()
	lc := len(c) - 1
	sum := g.NewElement().Set(c[lc])
	for i := lc - 1; i >= 0; i-- {
		sum.Mul(sum, s.ID)
		sum.Add(sum, c[i])
	}
	polI := g.NewElement().MulGen(s.Value)
	return polI.IsEqual(sum)
}

// Recover returns the secret provided more than t shares are given. Returns an
// error if the number of shares is not above the threshold t.
func (v VerifiableSecretSharing) Recover(shares []Share) (group.Scalar, error) {
	return v.s.Recover(shares)
}

type Splitter struct {
	g    group.Group
	t    uint
	poly polynomial.Polynomial
}

// NewSplitter returns a Splitter that can shard a secret with threshold t.
func NewSplitter(rnd io.Reader, t uint, secret group.Scalar) (sp Splitter) {
	sp.g = secret.Group()
	sp.t = t

	c := make([]group.Scalar, sp.t+1)
	c[0] = secret.Copy()
	for i := 1; i < len(c); i++ {
		c[i] = sp.g.RandomScalar(rnd)
	}
	sp.poly = polynomial.New(c)

	return
}

func (sp Splitter) multipleShard(n uint) ([]Share, error) {
	if n <= sp.t {
		return nil, errThreshold(sp.t, n)
	}

	shares := make([]Share, n)
	id := sp.g.NewScalar()
	for i := range shares {
		shares[i] = sp.ShardWithID(id.SetUint64(uint64(i + 1)))
	}

	return shares, nil
}

func (sp Splitter) Shard(rnd io.Reader) (s Share) {
	return sp.ShardWithID(sp.g.RandomNonZeroScalar(rnd))
}

func (sp Splitter) ShardWithID(id group.Scalar) (s Share) {
	if id.IsZero() {
		panic("secretsharing: id cannot be zero")
	}

	s.ID = id.Copy()
	s.Value = sp.poly.Evaluate(s.ID)
	return
}

func errThreshold(t, n uint) error {
	return fmt.Errorf("secretsharing: number of shares (n=%v) must be above the threshold (t=%v)", n, t)
}
